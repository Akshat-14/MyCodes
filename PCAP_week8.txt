/////////////////////////////////////////////////////////Q2 odd even transposition sort

#include <stdio.h>
#include <CL/cl.h>
#include <stdlib.h>
#include<string.h>

#define MAX_SOURCE_SIZE 0x100000

int main (void) {

    int i;

    int LIST_SIZE;

    printf("Enter the number of elements: ");
    scanf("%d", &LIST_SIZE);

    // -1. Create and initialize two vectors

    int *A = (int *)malloc(sizeof(int) * LIST_SIZE);
    //int *B = (int *)malloc(sizeof(int) * LIST_SIZE);

    printf("Enter the elements\n");
    for (i = 0; i < LIST_SIZE; ++i) {
        scanf("%d",&A[i]);
    }

    // 0. Load the kernel code

    FILE *kernel_code_file1 = fopen("sort.cl", "r");
    if (kernel_code_file1 == NULL) {
        printf("Kernel loading failed.");
        exit(1);
    }

    FILE *kernel_code_file2 = fopen("even.cl", "r");
        if (kernel_code_file2 == NULL) {
            printf("Kernel loading failed.");
            exit(1);
        }

    char *source_str1 = (char *)malloc(MAX_SOURCE_SIZE);
    size_t source_size1 = fread(source_str1, 1, MAX_SOURCE_SIZE, kernel_code_file1);

    char *source_str2 = (char *)malloc(MAX_SOURCE_SIZE);
        size_t source_size2 = fread(source_str2, 1, MAX_SOURCE_SIZE, kernel_code_file2);

    fclose(kernel_code_file1);
    fclose(kernel_code_file2);
    // 1. Get platform and device information

    cl_platform_id platform_id = NULL;
    cl_device_id device_id = NULL;

    cl_uint ret_num_devices, ret_num_platforms;

    cl_int ret = clGetPlatformIDs(1, &platform_id, &ret_num_platforms);
    ret = clGetDeviceIDs(platform_id, CL_DEVICE_TYPE_CPU, 1, &device_id, &ret_num_devices);


    // 2. Create an OpenCL context

    cl_context context = clCreateContext(NULL, 1, &device_id, NULL, NULL, &ret);


    // 3. Create a command queue

    cl_command_queue command_queue = clCreateCommandQueue(context, device_id,NULL, &ret);


    // 4. Create memory buffers on the device for each vector A, B and C

    cl_mem mem_obj_a = clCreateBuffer(context, CL_MEM_READ_WRITE, LIST_SIZE * sizeof(int), NULL, &ret);
    //cl_mem mem_obj_b = clCreateBuffer(context, CL_MEM_READ_ONLY, LIST_SIZE * sizeof(int), NULL, &ret);

    //cl_mem mem_obj_c = clCreateBuffer(context, CL_MEM_WRITE_ONLY, LIST_SIZE * sizeof(int), NULL, &ret);


    // 5. Copy the lists A and B to the respective memory buffers

    ret = clEnqueueWriteBuffer(command_queue, mem_obj_a, CL_TRUE, 0, LIST_SIZE * sizeof(int), A, 0, NULL, NULL);
    //ret = clEnqueueWriteBuffer(command_queue, mem_obj_c, CL_TRUE, 0, LIST_SIZE * sizeof(int), B, 0, NULL, NULL);


    // 6. Create a program from kernel source

    cl_program program1 = clCreateProgramWithSource(context, 1, (const char **)&source_str1, (const size_t *)&source_size1, &ret);
    cl_program program2 = clCreateProgramWithSource(context, 1, (const char **)&source_str2, (const size_t *)&source_size2, &ret);

    // 7. Build the kernel program

    ret = clBuildProgram(program1, 1, &device_id, NULL, NULL, NULL);
    ret = clBuildProgram(program2, 1, &device_id, NULL, NULL, NULL);

    // 8. Create the OpenCL kernel object

    cl_kernel kernel1 = clCreateKernel(program1, "odd", &ret);
    cl_kernel kernel2 = clCreateKernel(program2, "even", &ret);

    // 9. Set the arguments of the kernel

    ret = clSetKernelArg(kernel1, 0, sizeof(cl_mem), (void *)&mem_obj_a);
    ret = clSetKernelArg(kernel2, 0, sizeof(cl_mem), (void *)&mem_obj_a);
    //ret = clSetKernelArg(kernel, 2, sizeof(cl_mem), (void *)&mem_obj_c);


    // 10. Execute the kernel on device

    size_t global_item_size = LIST_SIZE;
    size_t local_item_size = 1;

    // cl_event event;
    for(i=0;i<LIST_SIZE/2;i++)
    {
        ret = clEnqueueNDRangeKernel(command_queue, kernel1, 1, NULL, &global_item_size, &local_item_size, 0, NULL, NULL);
        ret = clEnqueueNDRangeKernel(command_queue, kernel2, 1, NULL, &global_item_size, &local_item_size, 0, NULL, NULL);
    }
    ret = clFinish(command_queue);


    // 11. Read the memory buffer C on the device to the local variable C, and display

    //int *C = (int *)malloc(sizeof(int) * LIST_SIZE);

    ret = clEnqueueReadBuffer(command_queue, mem_obj_a, CL_TRUE, 0, LIST_SIZE * sizeof(int), A, 0, NULL, NULL);

    for (i = 0; i < LIST_SIZE; ++i) {
        printf("%d ",A[i]);
    }


    // 12. Clean buffers and context

    clFlush(command_queue);
    clReleaseKernel(kernel1);
    clReleaseKernel(kernel2);
    clReleaseProgram(program1);
    clReleaseProgram(program2);
    clReleaseMemObject(mem_obj_a);
    //clReleaseMemObject(mem_obj_b);

    clReleaseCommandQueue(command_queue);
    clReleaseContext(context);

    free(A);
    //free(C);

    int temp;
    printf("\n-------------------\n");
    //scanf(" %d", &temp);

    return 0;
}



/////////////////////////////////////////////////kernel for odd no

__kernel void odd(__global int*A){
	int idx = get_global_id(0);
	int size = get_global_size(0);
	if((idx%2)!=0 && idx+1 <= size-1){
		if(A[idx] >= A[idx+1]){
			int temp = A[idx];
			A[idx] = A[idx+1];
			A[idx+1] = temp;
		}
	}
}

////////////////////////////////////////////////kernel for even no

__kernel void even(__global int*A){
	int idx = get_global_id(0);
	int size = get_global_size(0);
	if((idx%2)== 0 && idx+1 <= size-1){
		if(A[idx] >= A[idx+1]){
			int temp = A[idx];
			A[idx] = A[idx+1];
			A[idx+1] = temp;
		}
	}
}

--------------------------------------------------*********************************************************************

///////////////////////////////////////////Q3 Occurences of a word

#include<stdio.h>
#include<CL/cl.h>
#include<stdlib.h>
#include<string.h>

#define MAX_SOURCE_SIZE (0x100000)

int main()
{
	int N,i=0;
	printf("Enter N : ");
	scanf("%d",&N);
	char buf[1000];
	gets(buf);
	gets(buf);
	while(buf[i]!=EOF)
		i++;
	int size_A=i;
	char *A=(char*)malloc(sizeof(char)*(size_A+1));
	for(i=0;i<=size_A;i++)
		A[i]=buf[i];
	gets(buf);
	i=0;
	while(buf[i]!=EOF)
		i++;
	int size_B=i;
	char *B=(char*)malloc(sizeof(char)*(size_B+1));
	for(i=0;i<=size_B;i++)
			B[i]=buf[i];
	FILE *fp;
	char *source_str;
	size_t source_size;
	fp=fopen("q3.cl","r");
	if(!fp)
	{
		printf("Failed to open\n");
		getchar();
		exit(1);
	}
	//printf("%s\n",A);
	//printf("%s\n",B);
	source_str=(char*)malloc(MAX_SOURCE_SIZE);
	source_size=fread(source_str,1,MAX_SOURCE_SIZE,fp);
	fclose(fp);
	cl_platform_id platform_id=NULL;
	cl_device_id device_id=NULL;
	cl_uint ret_num_devices;
	cl_uint ret_num_platforms;

	cl_int ret=clGetPlatformIDs(1,&platform_id,&ret_num_platforms);
	ret=clGetDeviceIDs(platform_id,CL_DEVICE_TYPE_CPU,1,&device_id,&ret_num_devices);
	cl_context context=clCreateContext(NULL,1,&device_id,NULL,NULL,&ret);
	cl_command_queue command_queue=clCreateCommandQueue(context,device_id,NULL,&ret);

	cl_mem a_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,size_A*sizeof(char),NULL,&ret);
	cl_mem b_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,size_B*sizeof(char),NULL,&ret);
	cl_mem c_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,N*sizeof(int),NULL,&ret);

	ret = clEnqueueWriteBuffer(command_queue,a_mem_obj,CL_TRUE,0,size_A*sizeof(char),A,0,NULL,NULL);
	ret = clEnqueueWriteBuffer(command_queue,b_mem_obj,CL_TRUE,0,size_B*sizeof(char),B,0,NULL,NULL);

	cl_program program = clCreateProgramWithSource(context,1,(const char**)&source_str,(const size_t *)&source_size,&ret);

	ret = clBuildProgram(program,1,&device_id,NULL,NULL,NULL);

	cl_kernel kernel = clCreateKernel(program,"vector_add",&ret);

	ret = clSetKernelArg(kernel,0,sizeof(cl_mem),(void *)&a_mem_obj);
	ret = clSetKernelArg(kernel,1,sizeof(cl_mem),(void *)&b_mem_obj);
	ret = clSetKernelArg(kernel,2,sizeof(cl_mem),(void *)&c_mem_obj);

	size_t globalWorkSize = N;
	size_t localWorkSize = 1;

	cl_event event;
	ret = clEnqueueNDRangeKernel(command_queue,kernel,1,NULL,&globalWorkSize,&localWorkSize,0,NULL,NULL);

	ret = clFinish(command_queue);
	int *C=(int*)malloc(sizeof(int)*N);

	ret = clEnqueueReadBuffer(command_queue,c_mem_obj,CL_TRUE,0,N*sizeof(int),C,0,NULL,NULL);

	int count=0;
	for(i=0;i<N;i++)
		count+=C[i];
	printf("%d",count);

	ret = clFlush(command_queue);
	ret = clReleaseKernel(kernel);
	ret = clReleaseProgram(program);
	ret = clReleaseMemObject(a_mem_obj);
	ret = clReleaseMemObject(b_mem_obj);
	ret = clReleaseCommandQueue(command_queue);
	ret = clReleaseContext(context);

	free(A);
	free(B);
	//getchar();
	return 0;
}


///////////////////////////////////////////kernel code

__kernel void vector_add(__global char *A,__global char *B,__global int *C)
{
	int i=get_global_id(0);
	int spaces=0;
	int l=0,r;
	while(spaces<i)
	{
		if(A[l]==' ')
			spaces++;
		l++;
	}
	r=l+1;
	while(A[r]!=' ' && A[r]!='\0')
		r++;
	r--;
	int j=0;
	while(A[l+j]==B[j] && l+j<=r)
		j++;
	
	if((A[l+j]==' ' || A[l+j]=='\0') && (B[j]=='\0'))
		C[i]=1;
	else
		C[i]=0;
}

-----------------------------------------------------------------***************************************************************************

//////////////////////////////Q1  string selection sort  N words

#include<stdio.h>
#include<CL/cl.h>
#include<stdlib.h>
#include<string.h>

int main()
	{
	int i;
	int m,*mat,*mat2,k=1;
	char s[100],res[100];
	//printf("\nEnter the value n:");
	//fflush(stdout);
	//scanf("%d",&m);
	printf("\nEnter the string:");
	gets(s);
	m=strlen(s);
	fflush(stdout);
	mat = (int*)calloc(m,sizeof(int*));
	mat2 = (int*)calloc(m,sizeof(int*));
	mat[0]=-1;
	for(i=0;i<m;i++){
		if(s[i]==' ')
			mat[k++]=i;
	}
	mat[k]=m;
	for(i=0;i<k;i++){
			printf("%d\n",mat[i]);
		}
	FILE *f1;
	char *src_str;
	size_t s_size;

	f1=fopen("selection.cl","r");

	if(f1==NULL)
	{
		fprintf(stdout,"File not found: ");
		fflush(stdout);
		exit(0);
	}
	src_str=(char *)malloc(100000);
	s_size=fread(src_str,sizeof(char),100000,f1);

	fclose(f1);

	cl_platform_id platform_id=NULL;
	cl_device_id device_id=NULL;
	cl_uint ret_num_devices,ret_num_platform;

	cl_int status=clGetPlatformIDs(1,&platform_id,&ret_num_platform);
	status=clGetDeviceIDs(platform_id,CL_DEVICE_TYPE_CPU,1,&device_id,&ret_num_devices);

	cl_context context=clCreateContext(NULL,1,&device_id,NULL,NULL,&status);

	cl_command_queue cq=clCreateCommandQueue(context,device_id,NULL,&status);

	cl_mem a_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,m*sizeof(char),NULL,&status);
	cl_mem b_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,(k+1)*sizeof(int),NULL,&status);
	//cl_mem b_mem_obj= clCreateBuffer(context,CL_MEM_WRITE_ONLY,n*sizeof(char),NULL,&status);
	cl_mem c_mem_obj= clCreateBuffer(context,CL_MEM_WRITE_ONLY,k*sizeof(int),NULL,&status);

	status= clEnqueueWriteBuffer(cq,a_mem_obj,CL_TRUE,0,m*sizeof(char),s,0,NULL,NULL);
	status= clEnqueueWriteBuffer(cq,b_mem_obj,CL_TRUE,0,(k+1)*sizeof(int),mat,0,NULL,NULL);

	cl_program program=clCreateProgramWithSource(context,1,(const char **)&src_str,(const size_t *)&s_size,&status);
	status=clBuildProgram(program,1,&device_id,NULL,NULL,NULL);

	cl_kernel kernel1 = clCreateKernel(program,"colOp",&status);
	size_t global_item_size=k;
	size_t local_item_size=1;
	status=clSetKernelArg(kernel1,0,sizeof(cl_mem),&a_mem_obj);
	status=clSetKernelArg(kernel1,1,sizeof(cl_mem),&b_mem_obj);
	status=clSetKernelArg(kernel1,2,sizeof(cl_mem),&c_mem_obj);
	status=clSetKernelArg(kernel1,3,sizeof(cl_int),&m);
	status=clSetKernelArg(kernel1,4,sizeof(cl_int),&k);

	status=clEnqueueNDRangeKernel(cq,kernel1,1,NULL,&global_item_size,&local_item_size,0,NULL,NULL);
	status=clFinish(cq);

	status=clEnqueueReadBuffer(cq,c_mem_obj,CL_TRUE,0,k*sizeof(int),mat2,0,NULL,NULL);
	for(i=0;i<k;i++){
		printf("%d\t",mat2[i]);
	}
	int x,y,z,j,temp=0;
	for(i=0;i<k;i++)
	{
		x=mat2[i];
		y=mat[x]+1;
		z=mat[x+1];
		for(j=y;j<z;j++)
			res[temp++]=s[j];
		res[temp++]=' ';
	}
	res[temp-1]='\0';

	printf("\n%s",res);


	status=clFlush(cq);
	status=clReleaseKernel(kernel1);
	status=clReleaseProgram(program);
	status=clReleaseMemObject(a_mem_obj);
	status=clReleaseCommandQueue(cq);
	status=clReleaseContext(context);
	free(mat);

	getchar();
	return 0;
}


///////////////////////kernel code
	__kernel void colOp(__global char *a,__global int *b,__global int *c,int m,int k){
	int id = get_global_id(0);
	int pos=b[id],i,j,count=0,str,end;
	for(i=0;i<k;i++){
		str=b[i]+1;
		end=b[i+1];
		for(j=pos+1;j<b[id+1];j++){	
			if(a[j]>a[str]){count++; break;}
			else if(a[j]<a[str]){break;}
			else{str++;continue;}
			if(str==end)break;
			}
		if(str==end && j==b[id+1]){if(i<id)count++;}
		}
	c[count] =id;
	}


--------------------------------------------------------*********************************************************************************

/////////////////////////////////////example code

include <stdio.h>
#include <stdlib.h>
#include <CL/cl.h>

#define MAX_SOURCE_SIZE (0x100000)

int main(void){
	//Create two input vector
	int i,LIST_SIZE;
	printf("Enter how many elements\n");
	scanf("%d",&LIST_SIZE);

	int *a = (int*)malloc(sizeof(int)*LIST_SIZE);

	//Initialize the input vector
	for(i = 0;i < LIST_SIZE;i++){
		printf("Enter %d values \n",LIST_SIZE);
		scanf("%d",&a[i]);
	}
	//Load the kernel source code into the array source_str
	FILE*fp;
	char* source_str;
	size_t source_size;

	fp = fopen("a.cl","r");

	if(!fp){
		fprintf(stderr,"Failed to load kernel\n");
		getchar();
		exit(1);
	}
	source_str = (char*)malloc(MAX_SOURCE_SIZE);
	source_size = fread(source_str,1,MAX_SOURCE_SIZE,fp);

	fclose(fp);

	//Get platform and device info
	cl_platform_id platform_id = NULL;
	cl_device_id device_id = NULL;
	cl_uint ret_num_devices;
	cl_uint ret_num_platforms;

	cl_int ret = clGetPlatformIDs(1,&platform_id,&ret_num_platforms);
	ret = clGetDeviceIDs(platform_id,CL_DEVICE_TYPE_GPU,1,&device_id,&ret_num_devices);

	//Create an opencl context
	cl_context context = clCreateContext(NULL,1,&device_id,NULL,NULL,&ret);

	//Create a command queue
	cl_command_queue command_queue = clCreateCommandQueue(context,device_id,NULL,&ret);

	//Create memory buffers
	cl_mem a_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,LIST_SIZE*sizeof(int),NULL,&ret);
	cl_mem b_mem_obj = clCreateBuffer(context,CL_MEM_WRITE_ONLY,LIST_SIZE*sizeof(int),NULL,&ret);

	//Copy the lists A to their respective memory buffer
	ret = clEnqueueWriteBuffer(command_queue, a_mem_obj, CL_TRUE,0,LIST_SIZE*sizeof(int),a,0,NULL,NULL);

	//Create a program from the kernel source
	cl_program program = clCreateProgramWithSource(context,1,(const char**)&source_str,(const size_t*)&source_size,&ret);

	//Build the program
	ret = clBuildProgram(program,1,&device_id,NULL,NULL,NULL);

	//Create the OpenCL kernel
	cl_kernel kernel = clCreateKernel(program,"sort_vector",&ret);

	//Set the arguments of the kernel
	ret = clSetKernelArg(kernel,0,sizeof(cl_mem),(void*)&a_mem_obj);
	ret = clSetKernelArg(kernel,0,sizeof(cl_mem),(void*)&b_mem_obj);

	//Execute the OpenCL kernel on the array
	size_t global_item_size = LIST_SIZE;
	size_t local_item_size = 1;

	//Read the memory buffer C on the device to the local variable C'
	int *RES = (int*)malloc(sizeof(int)*LIST_SIZE);

	cl_event event;
	ret = clEnqueueNDRangeKernel(command_queue,kernel,1,NULL,&global_item_size,&local_item_size,0,NULL,NULL);
	ret = clFinish(command_queue);
	ret = clEnqueueReadBuffer(command_queue,b_mem_obj,CL_TRUE,0,LIST_SIZE*sizeof(int),RES,0,NULL,NULL);

	//Display the result to the screen
	printf("Sorted Array\n");
	for(i=0;i < LIST_SIZE;i++)
		printf("%d = %d \n",a[i],RES[i]);

	//Clean Up
	ret = clFlush(command_queue);
	ret = clReleaseMemObject(a_mem_obj);
	ret = clReleaseMemObject(b_mem_obj);
	ret = clReleaseProgram(program);
	ret = clReleaseKernel(kernel);
	ret = clReleaseCommandQueue(command_queue);
	ret = clReleaseContext(context);

	free(a);
	free(RES);
	getchar();
	return 0;
}

//////////////////////////////////////////////////kernel code

__kernel void sort_vector(__global int*A,__global int*RES){
	//Get the index of current work item
	int id = get_global_id(0);
	int data = A[id];
	
	int n = get_global_size(0);
	int i,pos = 0;
	for(i=0;i<n;i++){
		if((A[i]<data) || (A[i]==data && i<id))
			pos++;
	} 
	RES[pos] = data;
}


