/////////////////////Example Program

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <CL/cl.h>

#define MAX_SOURCE_SIZE (0x100000)

//width & height of matrices
#define WA 3
#define HA 2
#define WB 3
#define HB 3
#define WC 3
#define HC 2
#define BLOCK_SIZE 1

int main(void){
	unsigned int size_A = WA*HA;
	unsigned int size_B = WB*HB;
	int* a = (int*)malloc(size_A*sizeof(int));
	int* b = (int*)malloc(size_B*sizeof(int));

	FILE*fp;
	char* source_str;
	size_t source_size;

	fp = fopen("replace.cl","r");
	if(!fp){
		fprintf(stderr,"Failed to load kernel\n");
		getchar();
		exit(1);
	}

	source_str = (char*)malloc(MAX_SOURCE_SIZE);
	source_size = fread(source_str,1,MAX_SOURCE_SIZE,fp);

	fclose(fp); 	//close file pointer
	int i;
	for(i=0;i<size_A;i++)
		scanf("%d",&a[i]);

	for(i=0;i<size_B;i++)
			scanf("%d",&b[i]);

	unsigned int size_C = WC * HC;
	int* c = (int*)malloc(size_C*sizeof(int));

	//Get platform and device information
	cl_platform_id platform_id = NULL;
	cl_device_id device_id = NULL;
	cl_uint ret_num_devices;
	cl_uint ret_num_platforms;

	cl_int ret = clGetPlatformIDs(1,&platform_id,&ret_num_platforms);
	ret = clGetDeviceIDs(platform_id,CL_DEVICE_TYPE_CPU,1,&device_id,&ret_num_devices);

	//Create opencl context
	cl_context context = clCreateContext(NULL,1,&device_id,NULL,NULL,&ret);

	//Create a command queue
	cl_command_queue command_queue = clCreateCommandQueue(context,device_id,NULL,&ret);

	cl_program clProgram = clCreateProgramWithSource(context,1,(const char**)&source_str,(const size_t*)&source_size,&ret);
	ret = clBuildProgram(clProgram,0,NULL,NULL,NULL,NULL);

	//Create memory buffers
	cl_mem a_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,size_A*sizeof(int),NULL,&ret);
	cl_mem b_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,size_B*sizeof(int),NULL,&ret);
	cl_mem c_mem_obj = clCreateBuffer(context,CL_MEM_WRITE_ONLY,size_C*sizeof(int),NULL,&ret);

	//Copy lists A and B to their respective memory buffers
	ret = clEnqueueWriteBuffer(command_queue, a_mem_obj, CL_TRUE,0,size_A*sizeof(int),a,0,NULL,NULL);
	ret = clEnqueueWriteBuffer(command_queue, b_mem_obj, CL_TRUE,0,size_B*sizeof(int),b,0,NULL,NULL);

	//Create a program the kernel source
	cl_program program = clCreateProgramWithSource(context,1,(const char**)&source_str,(const size_t*)&source_size,&ret);

	//Build the program
	ret = clBuildProgram(program,1,&device_id,NULL,NULL,NULL);

	//Create an OpenCl kernel
	cl_kernel kernel = clCreateKernel(program,"mat_mul",&ret);

	//Set the arguments of the kernel
	int widthA = WA;
	int widthB = WB;
	ret = clSetKernelArg(kernel,0,sizeof(cl_mem),(void*)&a_mem_obj);
	ret = clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&b_mem_obj);
	ret = clSetKernelArg(kernel,2,sizeof(cl_mem),(void*)&c_mem_obj);
	ret = clSetKernelArg(kernel,3,sizeof(cl_int),&widthA);	//changes made
	ret = clSetKernelArg(kernel,4,sizeof(cl_int),&widthB);	//changes made
	size_t localWorkSize[2] = {BLOCK_SIZE,BLOCK_SIZE};
	size_t globalWorkSize[2] = {WC,HC};

	ret = clEnqueueNDRangeKernel(command_queue,kernel,2,NULL,globalWorkSize,localWorkSize,0,NULL,NULL);
	clFinish(command_queue);

	ret = clEnqueueReadBuffer(command_queue,c_mem_obj,CL_TRUE,0,size_C*sizeof(int),c,0,NULL,NULL);

	printf("\nMatrix C\n");
	for(i=0;i<size_C;i++){
		printf("%d\t",c[i]);

		if(((i+1)%WC)==0)
			printf("\n");
	}

	free(source_str);
	clReleaseContext(context);
	clReleaseKernel(kernel);
	clReleaseProgram(clProgram);
	clReleaseCommandQueue(command_queue);
	//getchar();

	return 0;
}

///////////////Kernel code

__kernel void mat_mul(__global int* A,__global int* B,__global int* C,int widthA,int widthB){
	
	int row = get_global_id(1);
	int col = get_global_id(0);
	int sum = 0;
	
	for(int i=0;i<widthA;i++){
		sum += A[row*widthA+i]*B[i*widthB+col];
	}
	C[row*widthB+col] = sum;
}


---------------------------------------------*************************************************************************************

///////////////////////question 1

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <CL/cl.h>

#define MAX_SOURCE_SIZE (0x100000)

//width & height of matrices
/*
#define WA 3
#define HA 2
#define WB 3
#define HB 3
#define WC 3
#define HC 2 */
#define BLOCK_SIZE 1

int main(void){
	int m,n;
	printf("Enter size of Matrix M x N \n");
	scanf("%d %d",&m,&n);
	unsigned int size_A = m*n;
//	unsigned int size_B = WB*HB;
	int* a = (int*)malloc(size_A*sizeof(int));
//	int* b = (int*)malloc(size_B*sizeof(int));

	FILE*fp;
	char* source_str;
	size_t source_size;

	fp = fopen("square.cl","r");
	if(!fp){
		fprintf(stderr,"Failed to load kernel\n");
		getchar();
		exit(1);
	}

	source_str = (char*)malloc(MAX_SOURCE_SIZE);
	source_size = fread(source_str,1,MAX_SOURCE_SIZE,fp);

	fclose(fp); 	//close file pointer
	int i;
	printf("Enter the matrix\n");
	for(i=0;i<size_A;i++)
		scanf("%d",&a[i]);

//	for(i=0;i<size_B;i++)
//			scanf("%d",&b[i]);

	unsigned int size_C = m*n;
	int* c = (int*)malloc(size_C*sizeof(int));

	//Get platform and device information
	cl_platform_id platform_id = NULL;
	cl_device_id device_id = NULL;
	cl_uint ret_num_devices;
	cl_uint ret_num_platforms;

	cl_int ret = clGetPlatformIDs(1,&platform_id,&ret_num_platforms);
	ret = clGetDeviceIDs(platform_id,CL_DEVICE_TYPE_CPU,1,&device_id,&ret_num_devices);

	//Create opencl context
	cl_context context = clCreateContext(NULL,1,&device_id,NULL,NULL,&ret);

	//Create a command queue
	cl_command_queue command_queue = clCreateCommandQueue(context,device_id,NULL,&ret);

	cl_program clProgram = clCreateProgramWithSource(context,1,(const char**)&source_str,(const size_t*)&source_size,&ret);
	ret = clBuildProgram(clProgram,0,NULL,NULL,NULL,NULL);

	//Create memory buffers
	cl_mem a_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,size_A*sizeof(int),NULL,&ret);
//	cl_mem b_mem_obj = clCreateBuffer(context,CL_MEM_READ_ONLY,size_B*sizeof(int),NULL,&ret);
	cl_mem c_mem_obj = clCreateBuffer(context,CL_MEM_WRITE_ONLY,size_C*sizeof(int),NULL,&ret);

	//Copy lists A and B to their respective memory buffers
	ret = clEnqueueWriteBuffer(command_queue, a_mem_obj, CL_TRUE,0,size_A*sizeof(int),a,0,NULL,NULL);
//	ret = clEnqueueWriteBuffer(command_queue, b_mem_obj, CL_TRUE,0,size_B*sizeof(int),b,0,NULL,NULL);

	//Create a program the kernel source
	cl_program program = clCreateProgramWithSource(context,1,(const char**)&source_str,(const size_t*)&source_size,&ret);

	//Build the program
	ret = clBuildProgram(program,1,&device_id,NULL,NULL,NULL);

	//Create an OpenCl kernel
	cl_kernel kernel = clCreateKernel(program,"mat_pow",&ret);

	//Set the arguments of the kernel
	int widthA = m;
//	int widthB = WB;
	ret = clSetKernelArg(kernel,0,sizeof(cl_mem),(void*)&a_mem_obj);
//	ret = clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&b_mem_obj);
	ret = clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&c_mem_obj);
	ret = clSetKernelArg(kernel,2,sizeof(cl_int),&widthA);	//changes made
//	ret = clSetKernelArg(kernel,4,sizeof(cl_int),&n);	//changes made
	size_t localWorkSize[2] = {BLOCK_SIZE,BLOCK_SIZE};
	size_t globalWorkSize[2] = {m,n};

	ret = clEnqueueNDRangeKernel(command_queue,kernel,2,NULL,globalWorkSize,localWorkSize,0,NULL,NULL);
	clFinish(command_queue);

	ret = clEnqueueReadBuffer(command_queue,c_mem_obj,CL_TRUE,0,size_C*sizeof(int),c,0,NULL,NULL);

	printf("\nMatrix C\n");
	for(i=0;i<size_C;i++){
		printf("%d\t",c[i]);

		if(((i+1)%m)==0)
			printf("\n");
	}

	free(source_str);
	clReleaseContext(context);
	clReleaseKernel(kernel);
	clReleaseProgram(clProgram);
	clReleaseCommandQueue(command_queue);
	//getchar();

	return 0;
}

//////////////////////kernel code

__kernel void mat_pow(__global int* A,__global int* C,int m){
	int row = get_global_id(1);
	int col = get_global_id(0);
	int res = 1;
	for(int i=0;i<=row;i++)
		res = res*A[row*m+col];
	C[row*m + col] = res;
}


-------------------------------------------------------------------****************************************************************

#include<stdio.h>
#include<CL/cl.h>
#include<stdlib.h>
#define MAX_S_S (0x100000)

int main(void)
{
	int i,a_r,a_c;
	int *A,*C;

	printf("Row and Col size of A:");
	scanf("%d %d",&a_r,&a_c);

	int na=a_r*a_c;
	int nc=na;
	A=(int*)malloc(na*sizeof(int));
	C=(int*)malloc(nc*sizeof(int));
	printf("Matrix A:");
	for(i=0;i<na;i++)
		scanf("%d",&A[i]);

	FILE *fp;
	char *s_str;
	size_t s_size;
	fp=fopen("main4.cl","r");
	if(!fp)	exit(0);
	s_str=(char*)malloc(MAX_S_S);
	s_size=fread(s_str,1,MAX_S_S,fp);
	fclose(fp);

	cl_int status;

	cl_uint nPl,nDev;
	cl_platform_id pid=NULL;
	cl_device_id did=NULL;
	status=clGetPlatformIDs(1,&pid,&nPl);
	status=clGetDeviceIDs(pid,CL_DEVICE_TYPE_CPU,1,&did,&nDev);

	cl_context context;
	context=clCreateContext(NULL,1,&did,NULL,NULL,&status);

	cl_command_queue cq;
	cq=clCreateCommandQueue(context,did,0,&status);

	cl_mem a,c;
	a=clCreateBuffer(context,CL_MEM_READ_ONLY,na*sizeof(int),NULL,&status);
	//b=clCreateBuffer(context,CL_MEM_READ_ONLY,nb*sizeof(int),NULL,&status);
	c=clCreateBuffer(context,CL_MEM_WRITE_ONLY,nc*sizeof(int),NULL,&status);

	status=clEnqueueWriteBuffer(cq,a,CL_TRUE,0,na*sizeof(int),A,0,NULL,NULL);
	//status=clEnqueueWriteBuffer(cq,b,CL_TRUE,0,nb*sizeof(int),B,0,NULL,NULL);

	cl_program prog;
	prog=clCreateProgramWithSource(context,1,(const char**)&s_str,(const size_t*)&s_size,&status);
	status=clBuildProgram(prog,1,&did,NULL,NULL,NULL);

	cl_kernel kernel;
	kernel=clCreateKernel(prog,"transpose",&status);

	status=clSetKernelArg(kernel,0,sizeof(cl_mem),(void*)&a);
	//status=clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&b);
	status=clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&c);
	status=clSetKernelArg(kernel,2,sizeof(int),&a_c);
	status=clSetKernelArg(kernel,3,sizeof(int),&a_r);

	size_t gl_i_s[2]={a_c,a_r};
	size_t lo_i_s[2]={1,1};

	status=clEnqueueNDRangeKernel(cq,kernel,2,NULL,gl_i_s,lo_i_s,0,NULL,NULL);
	status=clFinish(cq);

	status=clEnqueueReadBuffer(cq,c,CL_TRUE,0,nc*sizeof(int),C,0,NULL,NULL);

	printf("Result:\n");
	for(i=0;i<nc;i++)
	{
		printf("%d ",C[i]);
		if(((i+1)%a_r)==0)
			printf("\n");
	}

	clFlush(cq);
	clReleaseKernel(kernel);
	clReleaseProgram(prog);
	clReleaseMemObject(a);
	//clReleaseMemObject(b);
	clReleaseMemObject(c);
	clReleaseCommandQueue(cq);
	clReleaseContext(context);

	free(A);free(C);

	return 0;
}


///////kernel

__kernel void transpose(__global int *A,__global int *C,int a_c,int a_r)
{
	int row=get_global_id(1);
	int col=get_global_id(0);
	C[col*a_r+row]=A[row*a_c+col];
}

-----------------------------------------------*******************************************************************

//////////////////////////sum

#include<stdio.h>
#include<CL/cl.h>
#include<stdlib.h>
#define MAX_S_S (0x100000)

int main(void)
{
	int i,a_r,a_c;
	int *A,*C;

	printf("Row and Col size of A:");
	scanf("%d %d",&a_r,&a_c);

	int na=a_r*a_c;
	int nc=na;

	A=(int*)malloc(na*sizeof(int));
	//B=(int*)malloc(nb*sizeof(int));
	C=(int*)malloc(nc*sizeof(int));
	printf("Matrix A:");
	for(i=0;i<na;i++)
		scanf("%d",&A[i]);

	FILE *fp;
	char *s_str;
	size_t s_size;
	fp=fopen("abc.cl","r");
	if(!fp)	exit(0);
	s_str=(char*)malloc(MAX_S_S);
	s_size=fread(s_str,1,MAX_S_S,fp);
	fclose(fp);

	cl_int status;

	cl_uint nPl,nDev;
	cl_platform_id pid=NULL;
	cl_device_id did=NULL;
	status=clGetPlatformIDs(1,&pid,&nPl);
	status=clGetDeviceIDs(pid,CL_DEVICE_TYPE_CPU,1,&did,&nDev);

	cl_context context;
	context=clCreateContext(NULL,1,&did,NULL,NULL,&status);

	cl_command_queue cq;
	cq=clCreateCommandQueue(context,did,0,&status);

	cl_mem a,c;
	a=clCreateBuffer(context,CL_MEM_READ_ONLY,na*sizeof(int),NULL,&status);
	//b=clCreateBuffer(context,CL_MEM_READ_ONLY,nb*sizeof(int),NULL,&status);
	c=clCreateBuffer(context,CL_MEM_WRITE_ONLY,nc*sizeof(int),NULL,&status);

	status=clEnqueueWriteBuffer(cq,a,CL_TRUE,0,na*sizeof(int),A,0,NULL,NULL);
	//status=clEnqueueWriteBuffer(cq,b,CL_TRUE,0,nb*sizeof(int),B,0,NULL,NULL);

	cl_program prog;
	prog=clCreateProgramWithSource(context,1,(const char**)&s_str,(const size_t*)&s_size,&status);
	status=clBuildProgram(prog,1,&did,NULL,NULL,NULL);

	cl_kernel kernel;
	kernel=clCreateKernel(prog,"rowcolsum",&status);

	status=clSetKernelArg(kernel,0,sizeof(cl_mem),(void*)&a);
	//status=clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&b);
	status=clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&c);
	status=clSetKernelArg(kernel,2,sizeof(int),&a_c);
	//status=clSetKernelArg(kernel,4,sizeof(int),&b_c);

	size_t gl_i_s[2]={a_c,a_r};
	size_t lo_i_s[2]={1,1};

	status=clEnqueueNDRangeKernel(cq,kernel,2,NULL,gl_i_s,lo_i_s,0,NULL,NULL);
	status=clFinish(cq);

	status=clEnqueueReadBuffer(cq,c,CL_TRUE,0,nc*sizeof(int),C,0,NULL,NULL);

	printf("Matrix C:\n");
	for(i=0;i<nc;i++)
	{
		printf("%d ",C[i]);
		if(((i+1)%a_c)==0)
			printf("\n");
	}

	clFlush(cq);
	clReleaseKernel(kernel);
	clReleaseProgram(prog);
	clReleaseMemObject(a);
	//clReleaseMemObject(b);
	clReleaseMemObject(c);
	clReleaseCommandQueue(cq);
	clReleaseContext(context);

	free(A);free(C);

	return 0;
}


__kernel void rowcolsum(__global int *A,__global int *C,int a_c)
{
	int row=get_global_id(1);
	int col=get_global_id(0);
	int i,sum=0;

	for(i=0;i<a_c;i++)
		sum+=A[row*a_c+i]+A[a_c*i+col];
	C[row*a_c+col]=sum;
}


----------------------------------------------------------*****************************************************************

/////////////////////complement

#include<stdio.h>
#include<CL/cl.h>
#include<stdlib.h>
#define MAX_S_S (0x100000)

int main(void)
{
	int i,a_r,a_c;
	int *A;

	printf("Row and Col size of A:");
	scanf("%d %d",&a_r,&a_c);

	int na=a_r*a_c;

	A=(int*)malloc(na*sizeof(int));
	//B=(int*)malloc(nb*sizeof(int));
	//C=(int*)malloc(nc*sizeof(int));
	printf("Matrix A:");
	for(i=0;i<na;i++)
		scanf("%d",&A[i]);

	FILE *fp;
	char *s_str;
	size_t s_size;
	fp=fopen("complement.cl","r");
	if(!fp)	exit(0);
	s_str=(char*)malloc(MAX_S_S);
	s_size=fread(s_str,1,MAX_S_S,fp);
	fclose(fp);

	cl_int status;

	cl_uint nPl,nDev;
	cl_platform_id pid=NULL;
	cl_device_id did=NULL;
	status=clGetPlatformIDs(1,&pid,&nPl);
	status=clGetDeviceIDs(pid,CL_DEVICE_TYPE_CPU,1,&did,&nDev);

	cl_context context;
	context=clCreateContext(NULL,1,&did,NULL,NULL,&status);

	cl_command_queue cq;
	cq=clCreateCommandQueue(context,did,0,&status);

	cl_mem a;
	a=clCreateBuffer(context,CL_MEM_READ_ONLY,na*sizeof(int),NULL,&status);
	//b=clCreateBuffer(context,CL_MEM_READ_ONLY,nb*sizeof(int),NULL,&status);
	//c=clCreateBuffer(context,CL_MEM_WRITE_ONLY,nc*sizeof(int),NULL,&status);

	status=clEnqueueWriteBuffer(cq,a,CL_TRUE,0,na*sizeof(int),A,0,NULL,NULL);
	//status=clEnqueueWriteBuffer(cq,b,CL_TRUE,0,nb*sizeof(int),B,0,NULL,NULL);

	cl_program prog;
	prog=clCreateProgramWithSource(context,1,(const char**)&s_str,(const size_t*)&s_size,&status);
	status=clBuildProgram(prog,1,&did,NULL,NULL,NULL);

	cl_kernel kernel;
	kernel=clCreateKernel(prog,"ones",&status);

	status=clSetKernelArg(kernel,0,sizeof(cl_mem),(void*)&a);
	//status=clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&b);
	//status=clSetKernelArg(kernel,1,sizeof(cl_mem),(void*)&c);
	status=clSetKernelArg(kernel,1,sizeof(int),&a_r);
	status=clSetKernelArg(kernel,2,sizeof(int),&a_c);

	size_t gl_i_s[2]={a_c,a_r};
	size_t lo_i_s[2]={1,1};

	status=clEnqueueNDRangeKernel(cq,kernel,2,NULL,gl_i_s,lo_i_s,0,NULL,NULL);
	status=clFinish(cq);

	status=clEnqueueReadBuffer(cq,a,CL_TRUE,0,na*sizeof(int),A,0,NULL,NULL);

	printf("Result:\n");
	for(i=0;i<na;i++)
	{
		printf("%d ",A[i]);
		if(((i+1)%a_c)==0)
			printf("\n");
	}

	clFlush(cq);
	clReleaseKernel(kernel);
	clReleaseProgram(prog);
	clReleaseMemObject(a);
	//clReleaseMemObject(b);
	//clReleaseMemObject(c);
	clReleaseCommandQueue(cq);
	clReleaseContext(context);

	free(A);

	return 0;
}

////////////////////////////////kernel

__kernel void ones(__global int *A,int a_r,int a_c)
{
	int row=get_global_id(1);
	int col=get_global_id(0);
	int i;
	
	if(row==0 || row==a_r-1 || col==0 || col==a_c-1);
	else
	{
		int rem,sum=0,p=1;
		int num=A[row*a_c+col];
		while(num!=0)
		{
			rem=num%2;
			if(rem==0)
				rem=1;
			else
				rem=0;
			sum=sum+rem*p;
			num=num/2;
			p=p*10;
		}
		A[row*a_c+col]=sum;
	}
}


